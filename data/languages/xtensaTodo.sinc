macro pushVal(val32) {
    local addr:4 = a1;
    a1 = a1 - 4;
    *:4 addr = val32;
}

macro popVal(val32) {
    local addr:4 = a1;
    val32  =  *:4 addr;
    a1 = a1 + 4;
}


macro save() {
      sa3 = a3;
      sa4 = a4;
      sa5 = a5;
      sa6 = a6;
      sa7 = a7;                  
}

macro restore() {
      a3 = sa3;
      a4 = sa4;
      a5 = sa5;
      a6 = sa6;
      a7 = sa7;                  
}


## Windowed Register Option ##

# CALL4 - Call PC-relative, Rotate Window by 4, pg. 298.
:call4 srel_6.23_sb2 is srel_6.23_sb2 & u2_4.5 = 0b01 & op0 = 0b0101 {
    local dst = srel_6.23_sb2;
    a2=a6;
    a3=a7;
    a4=a8;
    a5=a9;
    a0 = inst_start + 3;
    call [dst];
}

# CALL8 - Call PC-relative, Rotate Window by 8, pg. 300.
:call8 srel_6.23_sb2 is srel_6.23_sb2 & u2_4.5 = 0b10 & op0 = 0b0101 {
    local dst = srel_6.23_sb2;
    save();
    #s2=a2;
    #s3=a3;
    #s4=a4;
    #s5=a5;
    #s6=a6;
    #s7=a7;
    a2=a10;
    a3=a11;
    a4=a12;
    a5=a13;
    a6=a14;
    a7=a15;    
    a0 = inst_start + 3;
    call [dst];
    restore();
}

# CALL12 - Call PC-relative, Rotate Window by 12, pg. 302.
:call12 srel_6.23_sb2 is srel_6.23_sb2 & u2_4.5 = 0b11 & op0 = 0b0101 {
    local dst = srel_6.23_sb2;
    a2=a14;
    a3=a15;
    a0 = inst_start + 3;
    call [dst];
}

# ENTRY - Subroutine Entry, pg. 340.
:entry as, u15_12.23_sb3 is u15_12.23_sb3 & as & u2_6.7 = 0b00 & u2_4.5 = 0b11 & op0 = 0b0110 {
    local amn = sext(u15_12.23_sb3);
    #as = as + amn;
    WindowBase    = amn;
    a1 = a1 - amn;
}

#    if (u15_12.23_sb3 ==4)
#        goto <shift4>;
#    if (u15_12.23_sb3 ==8)
#        goto <shift8>;
#    if (u15_12.23_sb3 ==12)
#        goto <shift12>;
#    <shift4>
#        a2=a6;
#        a3=a7;
#        a4=a8;
#        a5=a9;
#        a6=a10;
#        a7=a11;
#        a8=a12;
#        a9=a13;
#        a10=a14;
#        a11=a15;
#        goto <end>;
#    <shift8>
#        a2=a10;
#        a3=a11;
#        a4=a12;
#        a5=a13;
#        a6=a14;
#        a7=a15;
#        goto <end>;
#    <shift12>
#        a2=a14;
#        a3=a15;
#    <end>





# CALLX4 - Call Register, Rotate Window by 4, pg. 305.
:callx4 as is op2 = 0 & op1 = 0 & ar = 0 & as & u2_6.7 = 0b11 & u2_4.5 = 0b01 & op0 = 0 {
    local dst = as;
    a2=a6;
    a3=a7;
    a4=a8;
    a5=a9;
    a6=a10;
    a7=a11;
    a8=a12;
    a9=a13;
    a10=a14;
    a11=a15;
    a0 = inst_start + 3;
    call [dst];
}

# CALLX8 - Call Register, Rotate Window by 8, pg. 307.
:callx8 as is op2 = 0 & op1 = 0 & ar = 0 & as & u2_6.7 = 0b11 & u2_4.5 = 0b10 & op0 = 0 {
    local dst = as;
    #s2=a2;
    #s3=a3;
    #s4=a4;
    #s5=a5;
    #s6=a6;
    #s7=a7;
    a2=a10;
    a3=a11;
    a4=a12;
    a5=a13;
    a6=a14;
    a7=a15;        
    a0 = inst_start + 3;
    call [dst];
}

# CALLX12 - Call Register, Rotate Window by 12, pg. 308.
:callx12 as is op2 = 0 & op1 = 0 & ar = 0 & as & u2_6.7 = 0b11 & u2_4.5 = 0b11 & op0 = 0 {
    local dst = as;
    a2=a14;
    a3=a15;
    a0 = inst_start + 3;
    call [dst];
}



# L32E - Load 32-bit for Window Exceptions, pg. 376.
:l32e at, as, s5_12.15_oex is op2 = 0 & op1 = 0b1001 & s5_12.15_oex & as & at & op0 = 0 unimpl

# MOVSP - Move to Stack Pointer, pg. 427.
:movsp at, as is op2 = 0 & op1 = 0 & ar = 0b0001 & as & at & op0 = 0 unimpl

# RETW - Windowed Return, pg. 480.
:retw is op2 = 0 & op1 = 0 & ar = 0 & as = 0 & u2_6.7 = 0b10 & u2_4.5 = 0b01 & op0 = 0 {
# Assume call8
    a10=a2;
    a11=a3;
    a12=a4;
    a13=a5;
    a14=a6;
    a15=a7;
    #a2=s2;
    #a3=s3;
    #a4=s4;
    #a5=s5;
    #a6=s6;
    #a7=s7;                        
    a1 = a1 + WindowBase;
    return [a0];
}

# RETW.N - Narrow Windowed Return, pg. 482.
:retw.n is n_ar = 0b1111 & n_as = 0 & n_at = 0b0001 & n_op0 = 0b1101 {
    a10=a2;
    a11=a3;
    a12=a4;
    a13=a5;
    a14=a6;
    a15=a7;
    a1 = a1 + WindowBase;
    return [a0];
}

# ROTW - Rotate Window, pg. 496.
:rotw s4_4.7 is op2 = 0b0100 & op1 = 0 & ar = 0b1000 & as = 0 & s4_4.7 & op0 = 0 {

}

# S32E - Store 32-bit for Window Exceptions, pg. 508.
:s32e at, as, s5_12.15_oex is op2 = 0b0100 & op1 = 0b1001 & s5_12.15_oex & as & at & op0 = 0 unimpl


## MAC16 option ##

# LDDEC - Load with Autodecrement, pg. 386.
:lddec "MAC16_REGS[" u2_12.13 "]", as is op2 = 0b1001 & op1 = 0 & u2_14.15 = 0 & u2_12.13 & as & at = 0 & op0 = 0b0100 unimpl

# LDINC - Load with Autoincrement, pg. 387.
:ldinc "MAC16_REGS[" u2_12.13 "]", as is op2 = 0b1000 & op1 = 0 & u2_14.15 = 0 & u2_12.13 & as & at = 0 & op0 = 0b0100 unimpl

# MULA.AA.* - Signed Multiply, pg. 431.
:mula.aa.* as, at is op2 = 0b0001 & u2_18.19 = 0b01 & ar = 0 & as & at & op0 = 0b0100 unimpl

# FIXME: Add remaining MUL.* opcodes.


## Loop Option ##

# LOOP - Loop, pg. 392.
:loop as, urel_16.23 is urel_16.23 & ar = 0b1000 & as & at = 0b0111 & op0 = 0b0110 unimpl

# LOOPGTZ - Loop if Greater Than Zero, pg. 394.
:loopgtz as, urel_16.23 is urel_16.23 & ar = 0b1010 & as & at = 0b0111 & op0 = 0b0110 unimpl

# LOOPNEZ - Loop if Not Equal Zero, pg. 396.
:loopnez as, urel_16.23 is urel_16.23 & ar = 0b1001 & as & at = 0b0111 & op0 = 0b0110 unimpl
